/**
 * 压缩前端的图片文件，并强制转换为 JPEG 格式。
 *
 * @param imageFile - 待压缩的图片文件 (File 类型)。
 * @param maxSizeKB - 压缩后的最大文件大小，单位是 KB。
 * @returns 返回一个 Promise，该 Promise 解决后会得到压缩后的 JPEG 格式的 File 对象。
 */
const compressImageToJpeg = (imageFile: File, maxSizeKB: number): Promise<File> => {
  return new Promise((resolve, reject) => {
    // 检查文件类型是否是图片
    if (!imageFile.type.startsWith('image/')) {
      reject(new Error('Input file is not an image.'));
      return;
    }

    const reader = new FileReader();
    reader.readAsDataURL(imageFile);

    reader.onload = (event) => {
      const img = new Image();
      img.src = event.target?.result as string;

      img.onload = () => {
        let canvas = document.createElement('canvas');
        let ctx = canvas.getContext('2d') as CanvasRenderingContext2D;

        const { width, height } = img;
        canvas.width = width;
        canvas.height = height;

        ctx.drawImage(img, 0, 0, width, height);

        let quality = 0.9;
        const maxSizeBytes = maxSizeKB * 1024;
        const outputMimeType = 'image/jpeg';

        // 递归压缩函数
        const recursiveCompress = () => {
          // 强制将图片导出为 JPEG 格式
          canvas.toBlob((blob) => {
            if (!blob) {
              reject(new Error('Failed to create blob from canvas.'));
              return;
            }

            // 如果大小已经小于最大尺寸，或者质量已经降到很低了（比如0.1），就返回
            if (blob.size <= maxSizeBytes || quality < 0.1) {
              // 创建一个新的 File 对象
              const outputFileName = imageFile.name.split('.')[0] + '.jpeg';
              const compressedFile = new File([blob], outputFileName, {
                type: outputMimeType,
                lastModified: Date.now(),
              });
              resolve(compressedFile);
              return;
            }

            // 否则，降低质量，继续递归压缩
            quality -= 0.1;
            recursiveCompress();
          }, outputMimeType, quality);
        };

        // 开始递归压缩
        recursiveCompress();
      };

      img.onerror = () => {
        reject(new Error('Failed to load the image.'));
      };
    };

    reader.onerror = () => {
      reject(new Error('Failed to read the file.'));
    };
  });
};

// --- 使用示例 ---

// 假设你有一个 file input 元素
const fileInput = document.getElementById('file-input') as HTMLInputElement;

fileInput?.addEventListener('change', async (event) => {
  const files = (event.target as HTMLInputElement).files;
  if (files && files.length > 0) {
    const originalFile = files[0];
    const maxSizeKB = 200; // 设定压缩后最大为 200KB

    console.log(`原始文件大小: ${(originalFile.size / 1024).toFixed(2)} KB, 格式: ${originalFile.type}`);

    try {
      // 调用新的压缩函数
      const compressedJpegFile = await compressImageToJpeg(originalFile, maxSizeKB);

      console.log(`压缩后文件大小: ${(compressedJpegFile.size / 1024).toFixed(2)} KB, 格式: ${compressedJpegFile.type}`);
      console.log(`文件名: ${compressedJpegFile.name}`);

      // 创建一个 URL 来预览压缩后的图片
      const compressedImageUrl = URL.createObjectURL(compressedJpegFile);
      const imgElement = document.getElementById('compressed-image') as HTMLImageElement;
      if (imgElement) {
        imgElement.src = compressedImageUrl;
      }
    } catch (error) {
      console.error('压缩图片时出错:', error);
    }
  }
});
